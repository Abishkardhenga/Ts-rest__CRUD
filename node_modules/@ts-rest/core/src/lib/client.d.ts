import { AppRoute, AppRouteMutation, AppRouter } from './dsl';
import { AreAllPropertiesOptional, Prettify } from './type-utils';
import { ClientInferRequest, ClientInferResponses, PartialClientInferRequest, NextClientArgs, Frameworks } from './infer-types';
type RecursiveProxyObj<T extends AppRouter, TClientArgs extends ClientArgs> = {
    [TKey in keyof T]: T[TKey] extends AppRoute ? AppRouteFunction<T[TKey], TClientArgs> : T[TKey] extends AppRouter ? RecursiveProxyObj<T[TKey], TClientArgs> : never;
};
/**
 * @deprecated Only safe to use on the client-side. Use `ServerInferResponses`/`ClientInferResponses` instead.
 */
export type ApiResponseForRoute<T extends AppRoute> = ClientInferResponses<T>;
/**
 * @deprecated Only safe to use on the client-side. Use `ServerInferResponses`/`ClientInferResponses` instead.
 */
export declare function getRouteResponses<T extends AppRouter>(router: T): ClientInferResponses<T>;
/**
 * Returned from a mutation or query call
 */
export type AppRouteFunction<TRoute extends AppRoute, TClientArgs extends ClientArgs, TArgs = PartialClientInferRequest<TRoute, TClientArgs>> = AreAllPropertiesOptional<TArgs> extends true ? (args?: Prettify<TArgs>) => Promise<Prettify<ClientInferResponses<TRoute>>> : (args: Prettify<TArgs>) => Promise<Prettify<ClientInferResponses<TRoute>>>;
export interface ClientArgs {
    baseUrl: string;
    baseHeaders: Record<string, string>;
    api?: ApiFetcher;
    credentials?: RequestCredentials;
    jsonQuery?: boolean;
}
export type ApiFetcherArgs = {
    route: AppRoute;
    path: string;
    method: string;
    headers: Record<string, string>;
    body: FormData | string | null | undefined;
    rawBody: unknown;
    rawQuery: unknown;
    contentType: AppRouteMutation['contentType'];
    credentials?: RequestCredentials;
    signal?: AbortSignal;
    cache?: RequestCache;
    /**
     * Only to be used by `@ts-rest/next`.
     * You can obtain a Nextjs Client by calling `initNextClient`
     */
    next?: NextClientArgs['next'] | undefined;
};
export type ApiFetcher = (args: ApiFetcherArgs) => Promise<{
    status: number;
    body: unknown;
    headers: Headers;
}>;
/**
 * Default fetch api implementation:
 *
 * Can be used as a reference for implementing your own fetcher,
 * or used in the "api" field of ClientArgs to allow you to hook
 * into the request to run custom logic
 */
export declare const tsRestFetchApi: ApiFetcher;
export declare const fetchApi: ({ path, clientArgs, route, body, query, extraInputArgs, headers, signal, next, }: {
    path: string;
    clientArgs: ClientArgs;
    route: AppRoute;
    query: unknown;
    body: unknown;
    extraInputArgs: Record<string, unknown>;
    headers: Record<string, string | undefined>;
    signal?: AbortSignal | undefined;
    /**
     * only to be used by @ts-rest/next
     * You can obtain a Nextjs Client by calling `initNextClient`
     */
    next?: NextClientArgs['next'] | undefined;
}) => Promise<{
    status: number;
    body: unknown;
    headers: Headers;
}>;
/**
 * @hidden
 */
export declare const getCompleteUrl: (query: unknown, baseUrl: string, params: unknown, route: AppRoute, jsonQuery: boolean) => string;
export declare const getRouteQuery: <TAppRoute extends AppRoute, Framework extends Frameworks = "none">(route: TAppRoute, clientArgs: InitClientArgs) => (inputArgs?: (Framework extends "nextjs" ? {
    headers: {
        [x: Lowercase<string>]: any;
    };
    body: any;
    cache?: RequestCache | undefined;
    next?: {
        revalidate?: number | false | undefined;
        tags?: string[] | undefined;
    } | undefined;
    params: {
        [x: string]: any;
    };
    query: any;
    extraHeaders?: ({
        [x: Lowercase<string>]: undefined;
    } & Record<string, string | undefined>) | undefined;
} : {
    headers: {
        [x: Lowercase<string>]: any;
    };
    body: any;
    cache?: RequestCache | undefined;
    params: {
        [x: string]: any;
    };
    query: any;
    extraHeaders?: ({
        [x: Lowercase<string>]: undefined;
    } & Record<string, string | undefined>) | undefined;
}) | undefined) => Promise<{
    status: number;
    body: unknown;
    headers: Headers;
}>;
export type InitClientReturn<T extends AppRouter, TClientArgs extends ClientArgs> = RecursiveProxyObj<T, TClientArgs>;
export type InitClientArgs = ClientArgs & {
    /**
     * Ensures that the responses from the server match those defined in the
     * contract.
     */
    throwOnUnknownStatus?: boolean;
};
export declare const initClient: <T extends AppRouter, TClientArgs extends InitClientArgs>(router: T, args: TClientArgs) => RecursiveProxyObj<T, TClientArgs>;
export {};
